C251 COMPILER V5.60.0,  motor                                                              20/06/23  00:03:58  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE motor
OBJECT MODULE PLACED IN .\Out_File\motor.obj
COMPILER INVOKED BY: D:\Keil_v5\C251\BIN\C251.EXE ..\USER\src\motor.c XSMALL WARNINGLEVEL(0) BROWSE INCDIR(..\..\Librari
                    -es\libraries;..\..\Libraries\seekfree_libraries;..\..\Libraries\seekfree_peripheral;..\CODE;..\USER\inc;..\USER\src;..\.
                    -.\..\DIANCI;..\..\..\..\18--------) DEBUG PRINT(.\Out_File\motor.lst) TABS(2) OBJECT(.\Out_File\motor.obj) 

stmt  level    source

    1          /*
    2           * @Author: lanchanghai
    3           * @Date: 2023-06-09 22:32:02
    4           * @LastEditors: lanchanghai
    5           * @LastEditTime: 2023-06-11 14:48:23
    6           * @FilePath: \DIANCI\Project\USER\src\motor.c
    7           */
    8          #include "motor.h"
    9          int8 RUN =0; 
   10          #define duty_Max  32768 //4096*8=32768
   11                                   //duty_Max = Y(PID系数范围) * 4096 ， duty_Max是经过PID得出的输出控制量占空比 
   12          #define duty_Min -32768
   13          
   14          #define coefficient duty_Max/motorduty_Max  //32768/35000=0.936
   15          //定义一个期望速度（用脉冲数代表速度），因为运用四倍频，即其范围（0~4096）
   16          int16 expected_speedL,expected_speedR;
   17          float now_speedL,now_speedR;  //承接编码器中的速度脉冲数值
   18          //定义左右占空比，承接PID的输出值
   19          int32 out_duty_L,out_duty_R;
   20          /*************************************************************************
   21           *  函数名称：void motor_init(void)
   22           *  功能说明：电机PWM初始化
   23           *  参数说明：无
   24           *  函数返回：无
   25           *  修改时间：2023.4.24
   26           *  备    注：初始化电机io和PID参数
   27           *************************************************************************/
   28          void motor_init(void)
   29          {
   30   1        pwm_init(PWMA_CH1P_P10, 15000, 0); // P1 输出PWM频率15000HZ   占空比为百分之 pwm_duty / PWM_DUTY_MAX * 1
             -00
   31   1        pwm_init(PWMB_CH2_P21, 15000, 0);  // P2 输出PWM频率15000HZ   占空比为百分之 pwm_duty / PWM_DUTY_MAX * 1
             -00
   32   1        pwm_init(PWMB_CH1_P20, 15000, 0);  // P3 输出PWM频率15000HZ   占空比为百分之 pwm_duty / PWM_DUTY_MAX * 1
             -00
   33   1        pwm_init(PWMB_CH4_P23, 15000, 0);  // P4 输出PWM频率15000HZ   占空比为百分之 pwm_duty / PWM_DUTY_MAX * 1
             -00
   34   1      //PID参数初始化
   35   1          PIDL_Init(&pid_LL);
   36   1          PIDR_Init(&pid_RR);
   37   1      }
   38          
   39          /*************************************************************************
   40           *  函数名称：void PID_control(int16 expected_speedL,int16 expected_speedR)
   41           *  功能说明：把期望速度值，和编码器所得的现在速度值做差进行PID计算，得到输出的控制量
   42           *  参数说明：无
   43           *  函数返回：无
   44           *  修改时间：2023.4.24
   45           *  备    注：
   46           *************************************************************************/
   47          //因为占空比过大会导致电机损坏，故我们取了70%为最大占空比（35000），由于1024线编码器用了四倍频最大脉冲为4
             -086，
   48          //经过运算4096*8=32768，故取P I D（0~8）
   49          // 若要P I D（0~120）占空比的范围max= 4096 * PID范围；
   50          //此函数所得占空比和递给电机的占空比之间的比例系数为 duty_Max/(X*500)
   51          void PID_control(int32 expected_speedL,int32 expected_speedR)
   52          {
C251 COMPILER V5.60.0,  motor                                                              20/06/23  00:03:58  PAGE 2   

   53   1        float error_L,error_R;
   54   1      
   55   1          now_speedL = Read_encoderL();
   56   1          now_speedR = Read_encoderR();
   57   1          error_L = expected_speedL - now_speedL;
   58   1          error_R = expected_speedR - now_speedR;
   59   1      //增量式PID
   60   1          out_duty_L = (int32)(PIDL_Inc(error_L,&pid_LL));
   61   1        out_duty_L = (int32)(PIDR_Inc(error_R,&pid_RR));
   62   1      //电机占空比限制
   63   1        if(out_duty_L >duty_Max){out_duty_L = duty_Max;}
   64   1        if(out_duty_L <duty_Min){out_duty_L = duty_Min;}  
   65   1          if(out_duty_R >duty_Min){out_duty_R = duty_Max;}
   66   1          if(out_duty_R <duty_Min){out_duty_R = duty_Min;}
   67   1      
   68   1      }
   69          /*************************************************************************
   70           *  函数名称：void motor_Control(void)
   71           *  功能说明：将PID得到的输出量对电机转动进行控制
   72           *  参数说明：无
   73           *  函数返回：无
   74           *  修改时间：2023.4.24
   75           *  备    注：
   76           *************************************************************************/
   77          void motor_Control(void)
   78          {
   79   1           int16 dutyR =0;
   80   1         int16 dutyL =0;
   81   1      
   82   1        dutyL = out_duty_L;
   83   1        dutyR = out_duty_R;
   84   1      
   85   1        if(RUN == 1){//判断是否可以跑
   86   2      //前转
   87   2               if (dutyR >= 0) //右前进
   88   2           {
   89   3            pwm_duty(PWMA_CH1P_P10, dutyR); 
   90   3                pwm_duty(PWMB_CH2_P21, 0);  
   91   3           }
   92   2           if (dutyL >= 0)//左前进
   93   2          {
   94   3            pwm_duty(PWMB_CH1_P20, dutyL);  
   95   3                pwm_duty(PWMB_CH4_P23, 0);    
   96   3          }
   97   2      //后转
   98   2               if (dutyR < 0)//右后转
   99   2          {
  100   3            pwm_duty(PWMA_CH1P_P10, 0); 
  101   3                pwm_duty(PWMB_CH2_P21, -dutyR); 
  102   3          }
  103   2               if (dutyL < 0)
  104   2           {
  105   3            pwm_duty(PWMB_CH1_P20, 0);  
  106   3                pwm_duty(PWMB_CH4_P23, -dutyL);   
  107   3           }
  108   2           
  109   2        }
  110   1      
  111   1      }
  112          
  113          
  114          
  115          
  116          
  117          
  118          
C251 COMPILER V5.60.0,  motor                                                              20/06/23  00:03:58  PAGE 3   

  119          
  120          void qian(void) // P1-pwm  P2-0 P3-pwm P4-0时前转
  121          {
  122   1        pwm_duty(PWMA_CH1P_P10, 5000); // 占空比10%
  123   1        pwm_duty(PWMB_CH2_P21, 0);     // 占空比0%
  124   1        pwm_duty(PWMB_CH1_P20, 5000);  // 占空比10%
  125   1        pwm_duty(PWMB_CH4_P23, 0);     // 占空比0%
  126   1      }
  127          void hou(void) // P1-0  P2-pwm P3-0 P4-pwm时后转
  128          {
  129   1        pwm_duty(PWMA_CH3P_P14, 0);    // 占空比0%
  130   1        pwm_duty(PWMA_CH4P_P16, 5000); // 占空比10%
  131   1        pwm_duty(PWMB_CH1_P20, 0);     // 占空比0%
  132   1        pwm_duty(PWMB_CH4_P23, 5000);  // 占空比10%
  133   1      }
  134          void ting(void) // P1=P2 P3=P4或者P1.P2.P3.P4悬空时前转
  135          {
  136   1        pwm_duty(PWMA_CH3P_P14, 0); // 占空比0%
  137   1        pwm_duty(PWMA_CH4P_P16, 0); // 占空比0%
  138   1        pwm_duty(PWMB_CH1_P20, 0);  // 占空比0%
  139   1        pwm_duty(PWMB_CH4_P23, 0);  // 占空比0%
  140   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =       501     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =        21          4
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =         5     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
