C251 COMPILER V5.60.0,  direction                                                          20/06/23  03:21:24  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE direction
OBJECT MODULE PLACED IN .\Out_File\direction.obj
COMPILER INVOKED BY: D:\Keil_v5\C251\BIN\C251.EXE ..\USER\src\direction.c XSMALL WARNINGLEVEL(0) BROWSE INCDIR(..\..\Lib
                    -raries\libraries;..\..\Libraries\seekfree_libraries;..\..\Libraries\seekfree_peripheral;..\CODE;..\USER\inc;..\USER\src;
                    -..\..\..\DIANCI;..\..\..\..\18--------) DEBUG PRINT(.\Out_File\direction.lst) TABS(2) OBJECT(.\Out_File\direction.obj) 

stmt  level    source

    1          /*
    2           * @Author: lanchanghai
    3           * @Date: 2023-06-09 22:32:02
    4           * @LastEditors: lanchanghai
    5           * @LastEditTime: 2023-06-17 19:37:20
    6           * @FilePath: \DIANCI\Project\USER\src\direction.c
    7           */
    8          #include "headfile.h"
    9          
   10          float poserror=0;   //å¤–ç¯åå·®
   11          int Servo_duty=0;  //è½¬å‘è¾“å‡ºPWM
   12          DirectPidStruct Direction;
   13          //èˆµæœºå‚æ•°
   14          #define Servos_Middle 3390               // èˆµæœºä¸­å€¼       
   15          #define Servos_Zmax 3750                 // èˆµæœºå·¦æœ€å€¼       
   16          #define Servos_Ymax 2990                 // èˆµæœºå³æœ€å€¼
   17          //å®šä¹‰ADCçš„æœ€å€¼
   18          //å› ä¸ºä½¿ç”¨12ä½ç²¾åº¦ADCæ•… 2çš„12æ¬¡æ–¹=4096
   19          #define ADC_MAX    4096                  //ADC 12ä½ç²¾åº¦ 2çš„12æ¬¡æ–¹=4096
   20          #define ADC_MIN     0                    
   21          
   22          uint16 DMA_ADC_dat[ADC_CH][(ADC_DATA-4)/2];   //å°†DMAä¸­ADCæ•°æ®é«˜ä½ä½åˆå¹¶(æ¯ä¸€ä¸ªé€šé“è½¬æ¢å…
             -«æ¬¡)
   23          float average[ADC_CH]={0};  //ADCæ¯ä¸€ä¸ªé€šé“å»æ‰æœ€å¤§å°å€¼çš„å¹³å‡å€¼
   24          float normalization_result[ADC_CH];//å¹³å‡å€¼å½’ä¸€åŒ–
   25          
   26          
   27          
   28          //æŠŠDMAä¸­æ•°æ®å’Œåœ¨ä¸€èµ·12ä½æ•°æ®
   29          void pooled_data(void)
   30          {
   31   1           uint8 i,j,n=0,a;
   32   1           a=((ADC_DATA-4));//16
   33   1           for(i=0;i<ADC_CH;i++)
   34   1           {
   35   2             n=0;
   36   2           for(j=0;j<a;j=j+2)
   37   2           {
   38   3            DMA_ADC_dat[i][n] = ((uint16)DmaAdBuffer[i][j])<<8 | DmaAdBuffer[i][j+1];
   39   3             n++;
   40   3           }
   41   2      
   42   2           }
   43   1      
   44   1      }
   45          //è½¯ä»¶æ»¤æ³¢é™å¹…æ³•
   46          //é™å¹…æ³•æ»¤æ³¢//
   47          //å†’æ³¡æ’åºä¸€ä¸ªé€šé“ç”µæ„Ÿçš„å€¼//
   48          void bubble_sort(void)
   49          {
   50   1         uint8 i,j,n,a;
   51   1        uint16 temp;
   52   1          a=((ADC_DATA-4)/2);
   53   1          for(n=0;n<ADC_CH;n++)
   54   1          {
   55   2           for(i=0;i<a;i++)
   56   2           {
C251 COMPILER V5.60.0,  direction                                                          20/06/23  03:21:24  PAGE 2   

   57   3              for(j=0;j<a-1-i;j++)
   58   3              {
   59   4               if(DMA_ADC_dat[n][j]>DMA_ADC_dat[n][j+1])    //è¿™é‡Œé»˜è®¤é‡‡ç”¨å‡åºæ¥æ’åˆ— 
   60   4                {
   61   5                  temp = DMA_ADC_dat[n][j];
   62   5                  DMA_ADC_dat[n][j] = DMA_ADC_dat[n][j+1];
   63   5                  DMA_ADC_dat[n][j+1] = temp;
   64   5                }
   65   4              }
   66   3           }
   67   2          }
   68   1      }
   69          //æ’åºå®Œçš„æ•°ç»„å»æ‰ä¸‰ç»„æœ€å¤§æœ€å°å€¼æ±‚å¹³å‡å€¼
   70          void average_value(void)
   71          {
   72   1        uint8 i,n,a;
   73   1        char j;
   74   1        
   75   1          a=((ADC_DATA-4)/2);
   76   1          for(n=0;n<ADC_CH;n++)
   77   1          {
   78   2            average[n] = 0;
   79   2            for(j=5;j>=0;j++){  //å¾ªç¯é€’å›å¹³å‡å€¼6æ¬¡
   80   3             
   81   3           for(i=3;i<a-3;i++) //å»æ‰æœ€å¤§æœ€å°çš„å€¼
   82   3           {
   83   4             average[n] = average[n]+DMA_ADC_dat[n][i];
   84   4              
   85   4           }
   86   3             average[n] = average[n]/(a-j);
   87   3              
   88   3          }
   89   2           }
   90   1          }
   91          //å½’ä¸€åŒ–
   92          /*
   93          å½’ä¸€åŒ–çš„å…¬å¼å¦‚ä¸‹ï¼š(x-Min)/(Max-Min).å…¶ä¸­,xä¸ºå®æ—¶æ£€æµ‹åˆ°çš„å˜é‡,Minä¸Max
   94          ä¸ºæ ‡å®šçš„ç”µæ„Ÿé‡‡é›†æœ€å°ä¸æœ€å¤§å€¼.å…·ä½“ä»£ç å¦‚ä¸‹:
   95          AD_M_Left[0] =(uint16)(99*(LeftAverage[0]-M_Left_min)/(M_Left_max[0]-M_Left_min)+1);
   96          */
   97          //è‹¥æƒ³èˆµæœºæ›´é¡ºæ»‘å¯ä»¥å¯¹åå·®errorçš„è®¡ç®—è¿›è¡Œå¤„ç†ï¼Œä¾‹å¦‚å°†å½’ä¸€åŒ–åçš„å€¼å¼€æ–¹
   98          void normalization(void)
   99          {
  100   1          uint8 i;
  101   1          for(i=0;i<ADC_CH;i++)
  102   1          {
  103   2          normalization_result[i] =100*((average[i]-ADC_MIN)/(ADC_MAX-ADC_MIN));
  104   2      
  105   2          }
  106   1          
  107   1      }
  108          //å¼€æ–¹
  109          //======================================================================
  110          //å‡½æ•°åç§° : my_sqrt(float number)
  111          //åŠŸèƒ½æè¿° : å¼€å¹³æ–¹ç®—æ³•
  112          //è¾“å…¥å‚æ•° : 
  113          //è¾“å‡ºå‚æ•° : 
  114          //è¿”å›å€¼   : NONE
  115          //å¤‡æ³¨     :  
  116          //======================================================================
  117          float my_sqrt(float number)
  118          {
  119   1          long i;
  120   1          float x, y;
  121   1          const float f = 1.5F;
  122   1          x = number * 0.5F;
C251 COMPILER V5.60.0,  direction                                                          20/06/23  03:21:24  PAGE 3   

  123   1          y = number;
  124   1          i = * ( long * ) &y;
  125   1          i = 0x5f3759df - ( i >> 1 );
  126   1      
  127   1          y = * ( float * ) &i;
  128   1          y = y * ( f - ( x * y * y ) );
  129   1          y = y * ( f - ( x * y * y ) );
  130   1          return number * y;
  131   1      }
  132          float my_pow(float x)
  133          {
  134   1        return x*x;
  135   1      }
  136          //åœ¨è®¡ç®—åå·®ä¹‹å‰åº”è°ƒç”¨å¥½çš„å‡½æ•°
  137          void prepare_dat(void)
  138          {
  139   1         bubble_sort();//å†’æ³¡æ’åºä¸€ä¸ªé€šé“ç”µæ„Ÿçš„å€¼//
  140   1         average_value();//æ’åºå®Œçš„æ•°ç»„å»æ‰æœ€å¤§æœ€å°å€¼æ±‚å¹³å‡å€¼
  141   1         normalization();//å½’ä¸€åŒ–
  142   1      }
  143          //æµ®ç‚¹å‹çš„ç»å¯¹å€¼
  144          float fabs(float x)
  145          {
  146   1         if(x>=0) return x;
  147   1         if(x<0) return -x;
  148   1      
  149   1      
  150   1      }
  151          //======================================================================
  152          //å‡½æ•°åç§° : cal_poserror
  153          //åŠŸèƒ½æè¿° : å·®æ¯”å’Œè®¡ç®—è¯¯å·®
  154          //è¾“å…¥å‚æ•° : 
  155          //è¾“å‡ºå‚æ•° : 
  156          //è¿”å›å€¼   : NONE
  157          //å¤‡æ³¨     :  acrossæ¨ªç”µæ„Ÿ verticalç«–ç”µæ„Ÿ splayedå…«å­—å‹
  158          //        (/ å  å \)   
  159          // (A*(L-R)+B*(LM-RM))/(A*(L+R)+C*(|LM+RM|))
  160          //======================================================================
  161          //è‹¥è¾“å‡ºé‡è·Ÿèˆµæœºæ‰“è§’æœ‰åå·®éœ€è¦è°ƒæ•´ï¼Œæ”¹å˜ç³»æ•°A B C P
  162          void cal_poserror(float a_Ls,float a_La,float a_Lv,float a_Rs,float a_Ra,float a_Rv)
  163          {
  164   1         float cha ,he;
  165   1         float A=1,B=1,C=1,P=1;
  166   1         cha = my_sqrt(A*(a_La - a_Ra)) + my_sqrt(B*(a_Ls - a_Rs));
  167   1         he = my_sqrt(A*(a_La + a_Ra)) + my_sqrt(C*fabs(a_Ls - a_Rs));
  168   1         poserror = (cha/he)*P;
  169   1          
  170   1      }
  171          /*******************************************************************************
  172          * å‡½æ•°å   ï¼šsteering_angl
  173          * æè¿°      ï¼šèˆµæœºè§’åº¦è®¾ç½®
  174          * å‚æ•°      ï¼š
  175                      angl        èˆµæœºè§’åº¦ï¼ˆæ­£ï¼šå·¦è½¬  è´Ÿï¼šå³è½¬  360 <= angl <= -400ï¼‰
  176          * è¿”å›      :void
  177          * ç¼–å†™è€…   ï¼šXY
  178          * ç¼–å†™æ—¥æœŸ  ï¼š2021-12-19
  179          *******************************************************************************/
  180          void Steering_Angl(int angl)
  181          {
  182   1        int PWM1_duty;
  183   1        
  184   1          PWM1_duty = Servos_Middle  + angl;            //dutyå ç©ºæ¯”ä¸º3390æ—¶ï¼Œèˆµæœºå±…ä¸­
  185   1        if(PWM1_duty <= Servos_Ymax)//å³è½¬é™å¹…
  186   1          {PWM1_duty = Servos_Ymax;}
  187   1          if(PWM1_duty >= Servos_Zmax)//å·¦è½¬é™å¹…
  188   1          {PWM1_duty = Servos_Zmax;}
C251 COMPILER V5.60.0,  direction                                                          20/06/23  03:21:24  PAGE 4   

  189   1        pwm_init(PWMB_CH3_P22 , 50,PWM1_duty);  //PWMAè®¾ç½®å ç©ºæ¯”
  190   1        
  191   1        
  192   1      }
  193          
  194          //æ ¹æ®ä¸åŒå…ƒç´ åˆ¤æ–­ç³»æ•°PDçš„å€¼ï¼ˆDirectionï¼‰ï¼Œç”¨ADå€¼æ§åˆ¶èˆµæœºæ‰“è§’
  195          void Direction_out(void)
  196          {
  197   1        //è¿›è¡Œæ ‡å¿—ä½åˆ¤æ–­æ¥é…ç½®æ¯ä¸€ä¸ªèµ›é“å…ƒç´ çš„å‚æ•°å€¼  èˆµæœºä¸€åŠæœ€å€¼ä¸º360ï¼Œè¯¯å·®æœ€
             -å¤§18ï¼ŒPDç³»æ•°ä¸º20
  198   1        //è®©å…¶è¿‘ä¼¼ä¸€æ¯”ä¸€çš„å…³ç³»
  199   1        if(circular_flag ==1)
  200   1        {
  201   2          Direction.KP=5; 
  202   2          Direction.KD=2;
  203   2        }
  204   1         //è½¬å‘PDæ§åˆ¶
  205   1         Direction.SumError=Direction.KP*poserror+Direction.KD*(poserror-Direction.PrevError);//ç”µæ„Ÿå·®æ¯”å’Œç
             -®—å‡ºçš„åå·®åšå¢é‡å¼PDè®¡ç®—
  206   1         Direction.PrevError=poserror;
  207   1         Direction.Pre1_Error[3]= Direction.Pre1_Error[2];
  208   1         Direction.Pre1_Error[2]= Direction.Pre1_Error[1];
  209   1         Direction.Pre1_Error[1]= Direction.Pre1_Error[0];
  210   1         Direction.Pre1_Error[0]=Direction.SumError;
  211   1        //æ‹Ÿåˆæ²¡æœ‰æ”¹å˜æ•°å€¼
  212   1         Direction.Direct_Parameter=Direction.Pre1_Error[0]*0.8+Direction.Pre1_Error[1]*0.1+
  213   1                                      Direction.Pre1_Error[2]*0.06+Direction.Pre1_Error[3]*0.04 ;//æ›²çº¿æ‹Ÿåˆ   æœ€å°äºŒä¹˜
  214   1         Servo_duty = (int)(Direction.Direct_Parameter);
  215   1         //è½¬å‘é™åˆ¶å¹…åº¦
  216   1         if(Servo_duty >= 400) Servo_duty = 360;
  217   1         if(Servo_duty <= -360) Servo_duty -360;
  218   1          Steering_Angl(Servo_duty);
  219   1      }
  220          
  221          
  222          
  223          
  224          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =       957     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =       286         36
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        42     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
