C251 COMPILER V5.60.0,  direction                                                          24/06/23  21:20:37  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE direction
OBJECT MODULE PLACED IN .\Out_File\direction.obj
COMPILER INVOKED BY: D:\Keil_v5\C251\BIN\C251.EXE ..\USER\src\direction.c XSMALL WARNINGLEVEL(0) BROWSE INCDIR(..\..\Lib
                    -raries\libraries;..\..\Libraries\seekfree_libraries;..\..\Libraries\seekfree_peripheral;..\CODE;..\USER\inc;..\USER\src;
                    -..\..\..\DIANCI;..\..\..\..\18--------) DEBUG PRINT(.\Out_File\direction.lst) TABS(2) OBJECT(.\Out_File\direction.obj) 

stmt  level    source

    1          /*
    2           * @Author: lanchanghai
    3           * @Date: 2023-06-09 22:32:02
    4           * @LastEditors: lanchanghai
    5           * @LastEditTime: 2023-06-17 19:37:20
    6           * @FilePath: \DIANCI\Project\USER\src\direction.c
    7           */
    8          #include "headfile.h"
    9          
   10          float poserror=0;   //å¤–ç¯åå·®
   11          int Servo_duty=0;  //è½¬å‘è¾“å‡ºPWM
   12          DirectPidStruct Direction;
   13          //èˆµæœºå‚æ•°
   14          #define Servos_Middle 3390               // èˆµæœºä¸­å€¼       
   15          #define Servos_Zmax 3750                 // èˆµæœºå·¦æœ€å€¼       
   16          #define Servos_Ymax 2990                 // èˆµæœºå³æœ€å€¼
   17          //å®šä¹‰ADCçš„æœ€å€¼
   18          //å› ä¸ºä½¿ç”¨12ä½ç²¾åº¦ADCæ•… 2çš„12æ¬¡æ–¹=4096
   19          #define ADC_MAX    4096                  //ADC 12ä½ç²¾åº¦ 2çš„12æ¬¡æ–¹=4096
   20          #define ADC_MIN     0                    
   21          
   22          uint16 DMA_ADC_dat[ADC_CH][(ADC_DATA-4)/2];   //å°†DMAä¸­ADCæ•°æ®é«˜ä½ä½åˆå¹¶(æ¯ä¸€ä¸ªé€šé“è½¬æ¢å…
             -«æ¬¡)
   23          double average[ADC_CH]={0};  //ADCæ¯ä¸€ä¸ªé€šé“å»æ‰æœ€å¤§å°å€¼çš„å¹³å‡å€¼
   24          float normalization_result[ADC_CH];//å¹³å‡å€¼å½’ä¸€åŒ–
   25          
   26          
   27          
   28          //æŠŠDMAä¸­æ•°æ®å’Œåœ¨ä¸€èµ·12ä½æ•°æ®
   29          void pooled_data(void)
   30          {
   31   1           uint8 i,j,n=0,a;
   32   1           a=((ADC_DATA-4));//16
   33   1           for(i=0;i<ADC_CH;i++)
   34   1           {
   35   2             n=0;
   36   2           for(j=0;j<a;j=j+2)
   37   2           {
   38   3            DMA_ADC_dat[i][n] = ((uint16)DmaAdBuffer[i][j])<<8 | DmaAdBuffer[i][j+1];
   39   3             n++;
   40   3           }
   41   2      
   42   2           }
   43   1      
   44   1      }
   45          //è½¯ä»¶æ»¤æ³¢é™å¹…æ³•
   46          //é™å¹…æ³•æ»¤æ³¢//
   47          //å†’æ³¡æ’åºä¸€ä¸ªé€šé“ç”µæ„Ÿçš„å€¼//
   48          void bubble_sort(void)
   49          {
   50   1         uint8 i,j,n,a;
   51   1        uint16 temp;
   52   1          a=((ADC_DATA-4)/2);
   53   1          for(n=0;n<ADC_CH;n++)
   54   1          {
   55   2           for(i=0;i<a;i++)
   56   2           {
C251 COMPILER V5.60.0,  direction                                                          24/06/23  21:20:37  PAGE 2   

   57   3              for(j=0;j<a-1-i;j++)
   58   3              {
   59   4               if(DMA_ADC_dat[n][j]>DMA_ADC_dat[n][j+1])    //è¿™é‡Œé»˜è®¤é‡‡ç”¨å‡åºæ¥æ’åˆ— 
   60   4                {
   61   5                  temp = DMA_ADC_dat[n][j];
   62   5                  DMA_ADC_dat[n][j] = DMA_ADC_dat[n][j+1];
   63   5                  DMA_ADC_dat[n][j+1] = temp;
   64   5                }
   65   4              }
   66   3           }
   67   2          }
   68   1      }
   69          //æ’åºå®Œçš„æ•°ç»„å»æ‰ä¸‰ç»„æœ€å¤§æœ€å°å€¼æ±‚å¹³å‡å€¼
   70          void average_value(void)
   71          {
   72   1        uint8 i,n,a,j;
   73   1        double sum=0;
   74   1        
   75   1          a=((ADC_DATA-4)/2);
   76   1          for(n=0;n<ADC_CH;n++)
   77   1          {
   78   2            sum=0;
   79   2            average[n] = 0;
   80   2            
   81   2            for(j=0;j<=6;j++)
   82   2            {  //å¾ªç¯é€’å›å¹³å‡å€¼6æ¬¡
   83   3             if(j==0)
   84   3             {
   85   4               for(i=3;i<a-3;i++) //å»æ‰æœ€å¤§æœ€å°çš„å€¼
   86   4               {
   87   5                average[n] = average[n]+DMA_ADC_dat[n][i];
   88   5                
   89   5               }
   90   4              sum = average[n];
   91   4             }
   92   3             else {
   93   4              average[n] =average[n] +sum;
   94   4              sum = average[n];
   95   4             }
   96   3             
   97   3              sum = sum/(a+j-6); 
   98   3              
   99   3            
  100   3          }
  101   2             average[n]= sum ;
  102   2           }
  103   1          }
  104          //å½’ä¸€åŒ–
  105          /*
  106          å½’ä¸€åŒ–çš„å…¬å¼å¦‚ä¸‹ï¼š(x-Min)/(Max-Min).å…¶ä¸­,xä¸ºå®æ—¶æ£€æµ‹åˆ°çš„å˜é‡,Minä¸Max
  107          ä¸ºæ ‡å®šçš„ç”µæ„Ÿé‡‡é›†æœ€å°ä¸æœ€å¤§å€¼.å…·ä½“ä»£ç å¦‚ä¸‹:
  108          AD_M_Left[0] =(uint16)(99*(LeftAverage[0]-M_Left_min)/(M_Left_max[0]-M_Left_min)+1);
  109          */
  110          //è‹¥æƒ³èˆµæœºæ›´é¡ºæ»‘å¯ä»¥å¯¹åå·®errorçš„è®¡ç®—è¿›è¡Œå¤„ç†ï¼Œä¾‹å¦‚å°†å½’ä¸€åŒ–åçš„å€¼å¼€æ–¹
  111          void normalization(void)
  112          {
  113   1          uint8 i;
  114   1          for(i=0;i<ADC_CH;i++)
  115   1          {
  116   2          normalization_result[i] =100*((average[i]-ADC_MIN)/(ADC_MAX-ADC_MIN));
  117   2      
  118   2          }
  119   1          
  120   1      }
  121          //å¼€æ–¹
  122          //======================================================================
C251 COMPILER V5.60.0,  direction                                                          24/06/23  21:20:37  PAGE 3   

  123          //å‡½æ•°åç§° : my_sqrt(float number)
  124          //åŠŸèƒ½æè¿° : å¼€å¹³æ–¹ç®—æ³•
  125          //è¾“å…¥å‚æ•° : 
  126          //è¾“å‡ºå‚æ•° : 
  127          //è¿”å›å€¼   : NONE
  128          //å¤‡æ³¨     :  
  129          //======================================================================
  130          float my_sqrt(float number)
  131          {
  132   1          long i;
  133   1          float x, y;
  134   1          const float f = 1.5F;
  135   1          x = number * 0.5F;
  136   1          y = number;
  137   1          i = * ( long * ) &y;
  138   1          i = 0x5f3759df - ( i >> 1 );
  139   1      
  140   1          y = * ( float * ) &i;
  141   1          y = y * ( f - ( x * y * y ) );
  142   1          y = y * ( f - ( x * y * y ) );
  143   1          return number * y;
  144   1      }
  145          float my_pow(float x)
  146          {
  147   1        return x*x;
  148   1      }
  149          //åœ¨è®¡ç®—åå·®ä¹‹å‰åº”è°ƒç”¨å¥½çš„å‡½æ•°
  150          void prepare_dat(void)
  151          {
  152   1         bubble_sort();//å†’æ³¡æ’åºä¸€ä¸ªé€šé“ç”µæ„Ÿçš„å€¼//
  153   1         average_value();//æ’åºå®Œçš„æ•°ç»„å»æ‰æœ€å¤§æœ€å°å€¼æ±‚å¹³å‡å€¼
  154   1         normalization();//å½’ä¸€åŒ–
  155   1      }
  156          //æµ®ç‚¹å‹çš„ç»å¯¹å€¼
  157          float fabs(float x)
  158          {
  159   1         if(x>=0) return x;
  160   1         if(x<0) return -x;
  161   1      
  162   1      
  163   1      }
  164          //======================================================================
  165          //å‡½æ•°åç§° : cal_poserror
  166          //åŠŸèƒ½æè¿° : å·®æ¯”å’Œè®¡ç®—è¯¯å·®
  167          //è¾“å…¥å‚æ•° : 
  168          //è¾“å‡ºå‚æ•° : 
  169          //è¿”å›å€¼   : NONE
  170          //å¤‡æ³¨     :  acrossæ¨ªç”µæ„Ÿ verticalç«–ç”µæ„Ÿ splayedå…«å­—å‹
  171          //        (/ å  å \)   
  172          // (A*(L-R)+B*(LM-RM))/(A*(L+R)+C*(|LM+RM|))
  173          //======================================================================
  174          //è‹¥è¾“å‡ºé‡è·Ÿèˆµæœºæ‰“è§’æœ‰åå·®éœ€è¦è°ƒæ•´ï¼Œæ”¹å˜ç³»æ•°A B C P
  175          void cal_poserror(float a_Ls,float a_La,float a_Lv,float a_Rs,float a_Ra,float a_Rv)
  176          {
  177   1         float cha ,he;
  178   1         float A=1,B=1,C=1,P=1;
  179   1         cha = my_sqrt(A*(a_La - a_Ra)) + my_sqrt(B*(a_Ls - a_Rs));
  180   1         he = my_sqrt(A*(a_La + a_Ra)) + my_sqrt(C*fabs(a_Ls - a_Rs));
  181   1         poserror = (cha/he)*P;
  182   1          
  183   1      }
  184          /*******************************************************************************
  185          * å‡½æ•°å   ï¼šsteering_angl
  186          * æè¿°      ï¼šèˆµæœºè§’åº¦è®¾ç½®
  187          * å‚æ•°      ï¼š
  188                      angl        èˆµæœºè§’åº¦ï¼ˆæ­£ï¼šå·¦è½¬  è´Ÿï¼šå³è½¬  360 <= angl <= -400ï¼‰
C251 COMPILER V5.60.0,  direction                                                          24/06/23  21:20:37  PAGE 4   

  189          * è¿”å›      :void
  190          * ç¼–å†™è€…   ï¼šXY
  191          * ç¼–å†™æ—¥æœŸ  ï¼š2021-12-19
  192          *******************************************************************************/
  193          void Steering_Angl(int angl)
  194          {
  195   1        int PWM1_duty;
  196   1        
  197   1          PWM1_duty = Servos_Middle  + angl;            //dutyå ç©ºæ¯”ä¸º3390æ—¶ï¼Œèˆµæœºå±…ä¸­
  198   1        if(PWM1_duty <= Servos_Ymax)//å³è½¬é™å¹…
  199   1          {PWM1_duty = Servos_Ymax;}
  200   1          if(PWM1_duty >= Servos_Zmax)//å·¦è½¬é™å¹…
  201   1          {PWM1_duty = Servos_Zmax;}
  202   1        pwm_init(PWMB_CH3_P22 , 50,PWM1_duty);  //PWMAè®¾ç½®å ç©ºæ¯”
  203   1        
  204   1        
  205   1      }
  206          
  207          //æ ¹æ®ä¸åŒå…ƒç´ åˆ¤æ–­ç³»æ•°PDçš„å€¼ï¼ˆDirectionï¼‰ï¼Œç”¨ADå€¼æ§åˆ¶èˆµæœºæ‰“è§’
  208          void Direction_out(void)
  209          {
  210   1        //è¿›è¡Œæ ‡å¿—ä½åˆ¤æ–­æ¥é…ç½®æ¯ä¸€ä¸ªèµ›é“å…ƒç´ çš„å‚æ•°å€¼  èˆµæœºä¸€åŠæœ€å€¼ä¸º360ï¼Œè¯¯å·®æœ€
             -å¤§18ï¼ŒPDç³»æ•°ä¸º20
  211   1        //è®©å…¶è¿‘ä¼¼ä¸€æ¯”ä¸€çš„å…³ç³»
  212   1        if(circular_flag ==1)
  213   1        {
  214   2          Direction.KP=5; 
  215   2          Direction.KD=2;
  216   2        }
  217   1         //è½¬å‘PDæ§åˆ¶
  218   1         Direction.SumError=Direction.KP*poserror+Direction.KD*(poserror-Direction.PrevError);//ç”µæ„Ÿå·®æ¯”å’Œç
             -®—å‡ºçš„åå·®åšå¢é‡å¼PDè®¡ç®—
  219   1         Direction.PrevError=poserror;
  220   1         Direction.Pre1_Error[3]= Direction.Pre1_Error[2];
  221   1         Direction.Pre1_Error[2]= Direction.Pre1_Error[1];
  222   1         Direction.Pre1_Error[1]= Direction.Pre1_Error[0];
  223   1         Direction.Pre1_Error[0]=Direction.SumError;
  224   1        //æ‹Ÿåˆæ²¡æœ‰æ”¹å˜æ•°å€¼
  225   1         Direction.Direct_Parameter=Direction.Pre1_Error[0]*0.8+Direction.Pre1_Error[1]*0.1+
  226   1                                      Direction.Pre1_Error[2]*0.06+Direction.Pre1_Error[3]*0.04 ;//æ›²çº¿æ‹Ÿåˆ   æœ€å°äºŒä¹˜
  227   1         Servo_duty = (int)(Direction.Direct_Parameter);
  228   1         //è½¬å‘é™åˆ¶å¹…åº¦
  229   1         if(Servo_duty >= 400) Servo_duty = 400;
  230   1         if(Servo_duty <= -360) Servo_duty -360;
  231   1          Steering_Angl(Servo_duty);
  232   1      }
  233          
  234          
  235          
  236          
  237          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      1000     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =       286         36
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
C251 COMPILER V5.60.0,  direction                                                          24/06/23  21:20:37  PAGE 5   

  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        42     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
