C251 COMPILER V5.60.0,  direction                                                          20/06/23  00:03:59  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE direction
OBJECT MODULE PLACED IN .\Out_File\direction.obj
COMPILER INVOKED BY: D:\Keil_v5\C251\BIN\C251.EXE ..\USER\src\direction.c XSMALL WARNINGLEVEL(0) BROWSE INCDIR(..\..\Lib
                    -raries\libraries;..\..\Libraries\seekfree_libraries;..\..\Libraries\seekfree_peripheral;..\CODE;..\USER\inc;..\USER\src;
                    -..\..\..\DIANCI;..\..\..\..\18--------) DEBUG PRINT(.\Out_File\direction.lst) TABS(2) OBJECT(.\Out_File\direction.obj) 

stmt  level    source

    1          /*
    2           * @Author: lanchanghai
    3           * @Date: 2023-06-09 22:32:02
    4           * @LastEditors: lanchanghai
    5           * @LastEditTime: 2023-06-17 19:37:20
    6           * @FilePath: \DIANCI\Project\USER\src\direction.c
    7           */
    8          #include "headfile.h"
    9          
   10          float poserror=0;   //å¤–ç¯åå·®
   11          //èˆµæœºå‚æ•°
   12          #define Servos_Middle 3390               // èˆµæœºä¸­å€¼       
   13          #define Servos_Zmax 3750                 // èˆµæœºå·¦æœ€å€¼       
   14          #define Servos_Ymax 2990                 // èˆµæœºå³æœ€å€¼
   15          //å®šä¹‰ADCçš„æœ€å€¼
   16          //å› ä¸ºä½¿ç”¨12ä½ç²¾åº¦ADCæ•… 2çš„12æ¬¡æ–¹=4096
   17          #define ADC_MAX    4096                  //ADC 12ä½ç²¾åº¦ 2çš„12æ¬¡æ–¹=4096
   18          #define ADC_MIN     0                    
   19          
   20          uint16 DMA_ADC_dat[ADC_CH][(ADC_DATA-4)/2];   //å°†DMAä¸­ADCæ•°æ®é«˜ä½ä½åˆå¹¶(æ¯ä¸€ä¸ªé€šé“è½¬æ¢å…
             -«æ¬¡)
   21          float average[ADC_CH]={0};  //ADCæ¯ä¸€ä¸ªé€šé“å»æ‰æœ€å¤§å°å€¼çš„å¹³å‡å€¼
   22          float normalization_result[ADC_CH];//å¹³å‡å€¼å½’ä¸€åŒ–
   23          
   24          
   25          
   26          //æŠŠDMAä¸­æ•°æ®å’Œåœ¨ä¸€èµ·12ä½æ•°æ®
   27          void pooled_data(void)
   28          {
   29   1           uint8 i,j,n=0,a;
   30   1           a=((ADC_DATA-4));//16
   31   1           for(i=0;i<ADC_CH;i++)
   32   1           {
   33   2             n=0;
   34   2           for(j=0;j<a;j=j+2)
   35   2           {
   36   3            DMA_ADC_dat[i][n] = ((uint16)DmaAdBuffer[i][j])<<8 | DmaAdBuffer[i][j+1];
   37   3             n++;
   38   3           }
   39   2      
   40   2           }
   41   1      
   42   1      }
   43          //è½¯ä»¶æ»¤æ³¢é™å¹…æ³•
   44          //é™å¹…æ³•æ»¤æ³¢//
   45          //å†’æ³¡æ’åºä¸€ä¸ªé€šé“ç”µæ„Ÿçš„å€¼//
   46          void bubble_sort(void)
   47          {
   48   1         uint8 i,j,n,a;
   49   1        uint16 temp;
   50   1          a=((ADC_DATA-4)/2);
   51   1          for(n=0;n<ADC_CH;n++)
   52   1          {
   53   2           for(i=0;i<a;i++)
   54   2           {
   55   3              for(j=0;j<a-1-i;j++)
   56   3              {
C251 COMPILER V5.60.0,  direction                                                          20/06/23  00:03:59  PAGE 2   

   57   4               if(DMA_ADC_dat[n][j]>DMA_ADC_dat[n][j+1])    //è¿™é‡Œé»˜è®¤é‡‡ç”¨å‡åºæ¥æ’åˆ— 
   58   4                {
   59   5                  temp = DMA_ADC_dat[n][j];
   60   5                  DMA_ADC_dat[n][j] = DMA_ADC_dat[n][j+1];
   61   5                  DMA_ADC_dat[n][j+1] = temp;
   62   5                }
   63   4              }
   64   3           }
   65   2          }
   66   1      }
   67          //æ’åºå®Œçš„æ•°ç»„å»æ‰ä¸‰ç»„æœ€å¤§æœ€å°å€¼æ±‚å¹³å‡å€¼
   68          void average_value(void)
   69          {
   70   1        uint8 i,n,a;
   71   1        char j;
   72   1        
   73   1          a=((ADC_DATA-4)/2);
   74   1          for(n=0;n<ADC_CH;n++)
   75   1          {
   76   2            average[n] = 0;
   77   2            for(j=5;j>=0;j++){  //å¾ªç¯é€’å›å¹³å‡å€¼6æ¬¡
   78   3             
   79   3           for(i=3;i<a-3;i++) //å»æ‰æœ€å¤§æœ€å°çš„å€¼
   80   3           {
   81   4             average[n] = average[n]+DMA_ADC_dat[n][i];
   82   4              
   83   4           }
   84   3             average[n] = average[n]/(a-j);
   85   3              
   86   3          }
   87   2           }
   88   1          }
   89          //å½’ä¸€åŒ–
   90          /*
   91          å½’ä¸€åŒ–çš„å…¬å¼å¦‚ä¸‹ï¼š(x-Min)/(Max-Min).å…¶ä¸­,xä¸ºå®æ—¶æ£€æµ‹åˆ°çš„å˜é‡,Minä¸Max
   92          ä¸ºæ ‡å®šçš„ç”µæ„Ÿé‡‡é›†æœ€å°ä¸æœ€å¤§å€¼.å…·ä½“ä»£ç å¦‚ä¸‹:
   93          AD_M_Left[0] =(uint16)(99*(LeftAverage[0]-M_Left_min)/(M_Left_max[0]-M_Left_min)+1);
   94          */
   95          //è‹¥æƒ³èˆµæœºæ›´é¡ºæ»‘å¯ä»¥å¯¹åå·®errorçš„è®¡ç®—è¿›è¡Œå¤„ç†ï¼Œä¾‹å¦‚å°†å½’ä¸€åŒ–åçš„å€¼å¼€æ–¹
   96          void normalization(void)
   97          {
   98   1          uint8 i;
   99   1          for(i=0;i<ADC_CH;i++)
  100   1          {
  101   2          normalization_result[i] =100*((average[i]-ADC_MIN)/(ADC_MAX-ADC_MIN));
  102   2      
  103   2          }
  104   1          
  105   1      }
  106          //å¼€æ–¹
  107          //======================================================================
  108          //å‡½æ•°åç§° : my_sqrt(float number)
  109          //åŠŸèƒ½æè¿° : å¼€å¹³æ–¹ç®—æ³•
  110          //è¾“å…¥å‚æ•° : 
  111          //è¾“å‡ºå‚æ•° : 
  112          //è¿”å›å€¼   : NONE
  113          //å¤‡æ³¨     :  
  114          //======================================================================
  115          float my_sqrt(float number)
  116          {
  117   1          long i;
  118   1          float x, y;
  119   1          const float f = 1.5F;
  120   1          x = number * 0.5F;
  121   1          y = number;
  122   1          i = * ( long * ) &y;
C251 COMPILER V5.60.0,  direction                                                          20/06/23  00:03:59  PAGE 3   

  123   1          i = 0x5f3759df - ( i >> 1 );
  124   1      
  125   1          y = * ( float * ) &i;
  126   1          y = y * ( f - ( x * y * y ) );
  127   1          y = y * ( f - ( x * y * y ) );
  128   1          return number * y;
  129   1      }
  130          float my_pow(float x)
  131          {
  132   1        return x*x;
  133   1      }
  134          //åœ¨è®¡ç®—åå·®ä¹‹å‰åº”è°ƒç”¨å¥½çš„å‡½æ•°
  135          void prepare_dat(void)
  136          {
  137   1         bubble_sort();//å†’æ³¡æ’åºä¸€ä¸ªé€šé“ç”µæ„Ÿçš„å€¼//
  138   1         average_value();//æ’åºå®Œçš„æ•°ç»„å»æ‰æœ€å¤§æœ€å°å€¼æ±‚å¹³å‡å€¼
  139   1         normalization();//å½’ä¸€åŒ–
  140   1      }
  141          //æµ®ç‚¹å‹çš„ç»å¯¹å€¼
  142          float fabs(float x)
  143          {
  144   1         if(x>=0) return x;
  145   1         if(x<0) return -x;
  146   1      
  147   1      
  148   1      }
  149          //======================================================================
  150          //å‡½æ•°åç§° : cal_poserror
  151          //åŠŸèƒ½æè¿° : å·®æ¯”å’Œè®¡ç®—è¯¯å·®
  152          //è¾“å…¥å‚æ•° : 
  153          //è¾“å‡ºå‚æ•° : 
  154          //è¿”å›å€¼   : NONE
  155          //å¤‡æ³¨     :  acrossæ¨ªç”µæ„Ÿ verticalç«–ç”µæ„Ÿ splayedå…«å­—å‹
  156          //        (/ å  å \)   
  157          // (A*(L-R)+B*(LM-RM))/(A*(L+R)+C*(|LM+RM|))
  158          //======================================================================
  159          void cal_poserror(float a_Ls,float a_La,float a_Lv,float a_Rs,float a_Ra,float a_Rv)
  160          {
  161   1         float cha ,he;
  162   1         float A=1,B=1,C=1,P=1;
  163   1         cha = my_sqrt(A*(a_La - a_Ra)) + my_sqrt(B*(a_Ls - a_Rs));
  164   1         he = my_sqrt(A*(a_La + a_Ra)) + my_sqrt(C*fabs(a_Ls - a_Rs));
  165   1         poserror = (cha/he)*P;
  166   1          
  167   1      }
  168          
  169          
  170          
  171          
  172          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =       702     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =       244         36
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
C251 COMPILER V5.60.0,  direction                                                          20/06/23  00:03:59  PAGE 4   

  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        36     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
